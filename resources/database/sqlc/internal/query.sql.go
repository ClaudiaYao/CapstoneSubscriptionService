// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
)

const changeDishDeliveryStatus = `-- name: ChangeDishDeliveryStatus :many
update dish_delivery set status = $1 where subscription_dish_id = $2 and status = "(empty)"
returning id, subscription_dish_id, status, expected_time, delivery_time, note
`

type ChangeDishDeliveryStatusParams struct {
	Status             string `json:"status"`
	SubscriptionDishID string `json:"subscriptionDishID"`
}

func (q *Queries) ChangeDishDeliveryStatus(ctx context.Context, arg ChangeDishDeliveryStatusParams) ([]DishDelivery, error) {
	rows, err := q.db.QueryContext(ctx, changeDishDeliveryStatus, arg.Status, arg.SubscriptionDishID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DishDelivery
	for rows.Next() {
		var i DishDelivery
		if err := rows.Scan(
			&i.ID,
			&i.SubscriptionDishID,
			&i.Status,
			&i.ExpectedTime,
			&i.DeliveryTime,
			&i.Note,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const changeSubscriptionStatus = `-- name: ChangeSubscriptionStatus :one
update subscription set status = $1 where id = $2
returning id, user_id, playlist_id, customized, status, frequency, start_date, end_date
`

type ChangeSubscriptionStatusParams struct {
	Status string `json:"status"`
	ID     string `json:"id"`
}

func (q *Queries) ChangeSubscriptionStatus(ctx context.Context, arg ChangeSubscriptionStatusParams) (Subscription, error) {
	row := q.db.QueryRowContext(ctx, changeSubscriptionStatus, arg.Status, arg.ID)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PlaylistID,
		&i.Customized,
		&i.Status,
		&i.Frequency,
		&i.StartDate,
		&i.EndDate,
	)
	return i, err
}

const getDisDeliveryCondition = `-- name: GetDisDeliveryCondition :many
select id, subscription_dish_id, status, expected_time, delivery_time, note FROM dish_delivery where subscription_dish_id = $1
`

func (q *Queries) GetDisDeliveryCondition(ctx context.Context, subscriptionDishID string) ([]DishDelivery, error) {
	rows, err := q.db.QueryContext(ctx, getDisDeliveryCondition, subscriptionDishID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DishDelivery
	for rows.Next() {
		var i DishDelivery
		if err := rows.Scan(
			&i.ID,
			&i.SubscriptionDishID,
			&i.Status,
			&i.ExpectedTime,
			&i.DeliveryTime,
			&i.Note,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDishBySubscriptionID = `-- name: GetDishBySubscriptionID :many
select id, dish_id, subscription_id, schedule_time, frequency, note FROM subscription_dish where subscription_id = $1
`

func (q *Queries) GetDishBySubscriptionID(ctx context.Context, subscriptionID string) ([]SubscriptionDish, error) {
	rows, err := q.db.QueryContext(ctx, getDishBySubscriptionID, subscriptionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubscriptionDish
	for rows.Next() {
		var i SubscriptionDish
		if err := rows.Scan(
			&i.ID,
			&i.DishID,
			&i.SubscriptionID,
			&i.ScheduleTime,
			&i.Frequency,
			&i.Note,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscriptionByID = `-- name: GetSubscriptionByID :one
select id, user_id, playlist_id, customized, status, frequency, start_date, end_date FROM subscription where id = $1
`

func (q *Queries) GetSubscriptionByID(ctx context.Context, id string) (Subscription, error) {
	row := q.db.QueryRowContext(ctx, getSubscriptionByID, id)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PlaylistID,
		&i.Customized,
		&i.Status,
		&i.Frequency,
		&i.StartDate,
		&i.EndDate,
	)
	return i, err
}

const getSubscriptionByUserID = `-- name: GetSubscriptionByUserID :many
select id, user_id, playlist_id, customized, status, frequency, start_date, end_date FROM subscription where user_id = $1
`

func (q *Queries) GetSubscriptionByUserID(ctx context.Context, userID string) ([]Subscription, error) {
	rows, err := q.db.QueryContext(ctx, getSubscriptionByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Subscription
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.PlaylistID,
			&i.Customized,
			&i.Status,
			&i.Frequency,
			&i.StartDate,
			&i.EndDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertDishDelivery = `-- name: InsertDishDelivery :one
insert into dish_delivery ("id", "subscription_dish_id", "status",
  "expected_time", "delivery_time", "note")
  values ($1, $2, $3, $4, $5, $6)
  returning id, subscription_dish_id, status, expected_time, delivery_time, note
`

type InsertDishDeliveryParams struct {
	ID                 string         `json:"id"`
	SubscriptionDishID string         `json:"subscriptionDishID"`
	Status             string         `json:"status"`
	ExpectedTime       interface{}    `json:"expectedTime"`
	DeliveryTime       interface{}    `json:"deliveryTime"`
	Note               sql.NullString `json:"note"`
}

func (q *Queries) InsertDishDelivery(ctx context.Context, arg InsertDishDeliveryParams) (DishDelivery, error) {
	row := q.db.QueryRowContext(ctx, insertDishDelivery,
		arg.ID,
		arg.SubscriptionDishID,
		arg.Status,
		arg.ExpectedTime,
		arg.DeliveryTime,
		arg.Note,
	)
	var i DishDelivery
	err := row.Scan(
		&i.ID,
		&i.SubscriptionDishID,
		&i.Status,
		&i.ExpectedTime,
		&i.DeliveryTime,
		&i.Note,
	)
	return i, err
}

const insertDishes = `-- name: InsertDishes :one
insert into subscription_dish ("id", "dish_id", "subscription_id",
  "schedule_time", "frequency", "note")
  values ($1, $2, $3, $4, $5, $6)
  returning id, dish_id, subscription_id, schedule_time, frequency, note
`

type InsertDishesParams struct {
	ID             string         `json:"id"`
	DishID         string         `json:"dishID"`
	SubscriptionID string         `json:"subscriptionID"`
	ScheduleTime   interface{}    `json:"scheduleTime"`
	Frequency      string         `json:"frequency"`
	Note           sql.NullString `json:"note"`
}

func (q *Queries) InsertDishes(ctx context.Context, arg InsertDishesParams) (SubscriptionDish, error) {
	row := q.db.QueryRowContext(ctx, insertDishes,
		arg.ID,
		arg.DishID,
		arg.SubscriptionID,
		arg.ScheduleTime,
		arg.Frequency,
		arg.Note,
	)
	var i SubscriptionDish
	err := row.Scan(
		&i.ID,
		&i.DishID,
		&i.SubscriptionID,
		&i.ScheduleTime,
		&i.Frequency,
		&i.Note,
	)
	return i, err
}

const insertSubscription = `-- name: InsertSubscription :one
insert into subscription ("id", "user_id", "playlist_id",
  "customized", "status", "frequency", "start_date",
  "end_date" ) values ($1, $2, $3, $4, $5, $6, $7, $8)
  returning id, user_id, playlist_id, customized, status, frequency, start_date, end_date
`

type InsertSubscriptionParams struct {
	ID         string      `json:"id"`
	UserID     string      `json:"userID"`
	PlaylistID string      `json:"playlistID"`
	Customized bool        `json:"customized"`
	Status     string      `json:"status"`
	Frequency  string      `json:"frequency"`
	StartDate  interface{} `json:"startDate"`
	EndDate    interface{} `json:"endDate"`
}

func (q *Queries) InsertSubscription(ctx context.Context, arg InsertSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRowContext(ctx, insertSubscription,
		arg.ID,
		arg.UserID,
		arg.PlaylistID,
		arg.Customized,
		arg.Status,
		arg.Frequency,
		arg.StartDate,
		arg.EndDate,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PlaylistID,
		&i.Customized,
		&i.Status,
		&i.Frequency,
		&i.StartDate,
		&i.EndDate,
	)
	return i, err
}
